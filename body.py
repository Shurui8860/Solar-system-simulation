# body
# author: Shurui Zhang
# UUN: s2193407

import math
import numpy as np
from numpy.linalg import norm
import scipy.constants

# The class Body involves some basic calculation on a celestial body,
# including initialising the velocity by assuming uniform circular motion around a central body,
# updating the position of the body, updating the velocity, updating the acceleration,
# calculating the acceleration another body generated, calculating the kinetic energy,
# calculating the gravitational potential energy from another body,
# and checking whether this body has finished a period.


class Body(object):

    def __init__(self, name, mass, position, velocity, radius, colour):
        # The init method assign this body the initial velocity, the initial position,
        # initial acceleration, along with its name, mass, colour, and radius.
        self.name = name
        self.mass = mass
        self.position = position
        self.velocity = velocity
        self.current_acc = 0
        self.previous_acc = 0
        self.colour = colour
        self.radius = radius

        # period_recorder is used to determine whether this body has finished one period,
        # the first value of period_recorder is whether the body is above the x_axis in last iteration,
        # and the second one is whether the body is above the x_axis in current iteration.
        # if the period_recorder is [False, True], it means the body cross the x_axis in this iteration.
        self.period_recorder = [True, True]

    # This method is used to initialise the velocity by assuming uniform circular motion around a central body,
    # and assuming the initial position of the body is on the x_axis, which is the case in this simulation.
    def init_velocity(self, central_body):
        distance = norm(self.position - central_body.position)
        y_velocity = math.sqrt(scipy.constants.G * central_body.mass / distance)
        self.velocity = np.array([0, y_velocity])

    # This method is used to set a different initial acceleration for the body.
    def init_acc(self, acceleration):
        self.current_acc = acceleration
        self.previous_acc = acceleration

    # This method is to update the position of this body after a small timeinterval 'timestep'.
    # The now position is updated by the Beeman scheme.
    def update_position(self, timestep):
        dr = self.velocity * timestep + (4 * self.current_acc - self.previous_acc) * (timestep ** 2) / 6
        self.position = self.position + dr

    # This method is to update the velocity of this body after a small timeinterval 'timestep'.
    # The now velocity is updated by the Beeman scheme.
    def update_velocity(self, new_acc, timestep):
        dv = (2 * new_acc + 5 * self.current_acc - self.previous_acc) * timestep / 6
        self.velocity = self.velocity + dv

    # calculate the acceleration generated by another body
    def calc_acc(self, other_body):
        # The formula is given as a = F/m = -(G*M*r)/|r|^3
        pos_diff = other_body.position - self.position
        distance = norm(pos_diff)
        return scipy.constants.G * other_body.mass / (distance ** 3) * pos_diff

    # update the acceleration after another iteration
    def update_acc(self, new_acc):
        self.previous_acc = self.current_acc
        self.current_acc = new_acc

    # calculate the kinetic energy of this body.
    def calc_KE(self):
        # The formula is KE = (m*v^2)/2
        kinetic_energy = self.mass * (norm(self.velocity) ** 2) / 2
        return kinetic_energy

    # calculate the potential energy by another body.
    def calc_PE(self, other_body):
        # The formula is PE = -G*(M*m)/|r|
        distance = norm(other_body.position - self.position)
        return -scipy.constants.G * other_body.mass * self.mass / distance

    # update the period_recorder and determine whether the body has crossed the x-axis.
    def check_orbital_period(self):
        self.period_recorder[0] = self.period_recorder[1]
        self.period_recorder[1] = self.position[1] >= 0
        # refer to line 33-35 to see the algorithm.
        return self.period_recorder == [False, True]

